#include <iostream>
///////////SOCKET //////////////////
#include <sys/socket.h>
#include <netinet/in.h>

1. Création d'un socket

Pour créer un socket, on utilise la fonction socket(). Cette fonction prend trois arguments :
le domaine de l'adresse (par exemple, AF_INET pour IPv4)
le type de socket (par exemple, SOCK_STREAM pour TCP)
le protocole (généralement 0 pour utiliser le protocole par défaut).

    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
        std::cout << "socket creation failed" << std::endl;
        return 1;

2. Configuration des options de socket

setsockopt() permet de configurer les options d'un socket. Par exemple
pour permettre la réutilisation de l'adresse du socket, on peut utiliser SO_REUSEADDR.

    int opt = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
        perror("setsockopt");
        return 1;


bind() lie le socket à une adresse IP et un port spécifiques.

struct sockaddr_in address;
address.sin_family = AF_INET;
address.sin_addr.s_addr = INADDR_ANY; // Utilise l'adresse IP du système
address.sin_port = htons(8080); // Port en mode réseau

    if (bind(sockfd, (struct sockaddr*)&address, sizeof(address)) < 0)
        perror("bind failed");
        return 1;
4. Écoute des connexions entrantes

listen() permet au socket d'écouter les connexions entrantes.
    if (listen(sockfd, 3) < 0)
    perror("listen");
    return 1;

5. Acceptation d'une connexion

accept() accepte une connexion entrante et renvoie un nouveau descripteur
 de fichier pour la connexion.

    struct sockaddr_in client_address;
    socklen_t client_address_len = sizeof(client_address);
    int new_sockfd = accept(sockfd, (struct sockaddr*)&client_address, &client_address_len);
    if (new_sockfd < 0) {
        perror("accept");
        return 1;
    }

6. Envoi et réception de données

send() et recv() sont utilisés pour envoyer et recevoir des données sur le socket.

char buffer[1024] = "Hello, client!";
send(new_sockfd, buffer, strlen(buffer), 0);

char recv_buffer[1024];
recv(new_sockfd, recv_buffer, 1024, 0);

7. Fermeture du socket

close() est utilisé pour fermer le socket.

close(new_sockfd);
close(sockfd);

8. Utilisation de getaddrinfo

getaddrinfo() est utilisé pour obtenir des informations sur l'adresse d'un hôte.

struct addrinfo hints, *res;
memset(&hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_STREAM;

if (getaddrinfo("www.example.com", "http", &hints, &res) != 0) {
    perror("getaddrinfo");
    return 1;
}

9. Libération des ressources

freeaddrinfo() est utilisé pour libérer la mémoire allouée par getaddrinfo().

freeaddrinfo(res);

10. Utilisation de htons, htonl, ntohs, ntohl

Ces fonctions sont utilisées pour convertir
 les valeurs entre l'ordre des octets de l'hôte et l'ordre des octets réseau.

 uint16_t port = 8080;
port = htons(port); // Convertit en ordre des octets réseau

uint32_t ip = 0x12345678;
ip = htonl(ip); // Convertit en ordre des octets réseau

port = ntohs(port); // Convertit en ordre des octets hôte
ip = ntohl(ip); // Convertit en ordre des octets hôte

11. Utilisation de inet_addr et inet_ntoa

inet_addr() convertit une adresse IP en format chaîne de caractères en une adresse IP en format réseau. inet_ntoa() fait l'inverse.

struct in_addr ip_addr;
ip_addr.s_addr = inet_addr("192.168.1.1");

char* ip_str = inet_ntoa(ip_addr);

12. Utilisation de signal et sigaction

signal() et sigaction() sont utilisés pour gérer les signaux.

void signal_handler(int signum) {
    // Gestion du signal
}

signal(SIGINT, signal_handler);

13. Utilisation de lseek, fstat, fcntl

Ces fonctions sont utilisées pour manipuler les fichiers et les descripteurs de fichiers.

int fd = open("file.txt", O_RDONLY);
off_t offset = lseek(fd, 0, SEEK_END); // Trouve la fin du fichier

struct stat file_stat;
fstat(fd, &file_stat); // Obtient les informations sur le fichier

int flags = fcntl(fd, F_GETFL); // Obtient les drapeaux du fichier

14. Utilisation de poll

poll() est utilisé pour surveiller plusieurs descripteurs de fichiers pour des événements spécifiques.

struct pollfd fds[2];
fds[0].fd = sockfd;
fds[0].events = POLLIN;
fds[1].fd = new_sockfd;
fds[1].events = POLLIN;

int ret = poll(fds, 2, 1000); // Surveille les sockets pendant 1000 ms


• Utiliser votre client de référence avec votre serveur devra être similaire à l’utiliser
avec un serveur IRC officiel. Cependant, seules les fonctionnalités suivantes sont
obligatoires :
◦ Vous devez pouvoir vous authentifier, définir un nickname, un username, re-
joindre un channel, envoyer et recevoir des messages privés, avec votre client
de référence.
◦ Tous les messages envoyés par un client dans un channel doivent être transmis
à tous les clients ayant rejoint ce channel.
◦ Vous devez avoir des operators et des utilisateurs basiques.
◦ Vous devez donc implémenter les commandes spécifiques aux operateurs de
canaux.
◦ KICK - Ejecter un client du channel
◦ INVITE - Inviter un client au channel
◦ TOPIC - Modifier ou afficher le thème du channel
◦ MODE - Changer le mode du channel :
— i : Définir/supprimer le canal sur invitation uniquement
6
ft_irc Internet Relay Chat
— t : Définir/supprimer les restrictions de la commande TOPIC pour les opé-
rateurs de canaux
— k : Définir/supprimer la clé du canal (mot de passe)
— o : Donner/retirer le privilège de l’opérateur de canal
— l : Définir/supprimer la limite d’utilisateurs pour l





server is listening
Server is waiting for connections on port 1027
New connection from 127.0.0.1 on socket 4
=13][][A=65][P=80][ =32][L=76][S=83][
=10]
Received from client 4: [CAP LS
]
=13][][I=73][C=67][K=75][ =32][j=106][m=109][a=97][s=115][t=116][o=111][r=114][a=97][
=10][U=85][S=83][E=69][R=82][ =32][j=106][m=109][a=97][s=115][t=116][o=111][r=114][a=97][ =32][j=106][m=109][a=97][s=115][t=116][o=111][r=114][a=97][ =32][l=108][o=111][c=99][a=97][l=108][h=104][o=111][s=115][t=116][ =32][:=58][J=74][u=117][l=108][i=105][e=101][n=110][ =32][M=77][A=13][S=83][T=84][O=79][R=82][A=65][S=83][
=10]
Received from client 4: [NICK jmastora
USER jmastora jmastora localhost :Julien MASTORAS
]
=13][][O=79][D=68][E=69][ =32][W=87][e=101][l=108][c=99][o=111][m=109][e=101][ =32][t=116][o=111][ =32][t=116][h=104][e=101][ =32][I=73][R=82][C=67][ =32][N=78][e=101][t=116][w=119][o=111][r=114][k=107][ =32][ =32][+=43][i=105][
=10]
Received from client 4: [MODE Welcome to the IRC Network  +i
]
=13][][H=72][O=79][I=73][S=83][ =32][j=106][m=109][a=97][s=115][t=116][o=111][r=114][a=97][
=10]
Received from client 4: [WHOIS jmastora
]
=13][][I=73][N=78][G=71][ =32][i=105][r=114][c=99][.=46][e=101][x=120][a=97][m=109][p=112][l=108][e=101][.=46][c=99][o=111][m=109][
=10]
Received from client 4: [PING irc.example.com
]
=13][][O=79][I=73][N=78][ =32][#=35][t=116][e=101][s=115][t=116][
=10]
Received from client 4: [JOIN #test
]
=13][][R=82][I=73][V=86][M=77][S=83][G=71][ =32][d=100][e=101][s=115][t=116][i=105][n=110][a=97][t=116][a=97][i=105][r=114][e=101][ =32][:=58][C=67][o=111][u=117][c=99][o=111][u=117][
=10]
Received from client 4: [PRIVMSG destinataire :Coucou
]
=13][][R=82][I=73][V=86][M=77][S=83][G=71][ =32][#=35][t=116][e=101][s=115][t=116][ =32][:=58][c=99][o=111][u=117][c=99][o=111][u=117][
=10]
Received from client 4: [PRIVMSG #test :coucou
]